#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <inttypes.h>
#include <winsock2.h>
#include <ws2tcpip.h>

#pragma comment(lib, "ws2_32.lib")  

#define BACKLOG 5
#define CHUNK 4096

int send_all(SOCKET s, const void *buf, size_t len) {
    size_t sent = 0;
    const char *p = (const char*)buf;
    while (sent < len) {
        int n = send(s, p + sent, (int)(len - sent), 0);
        if (n == SOCKET_ERROR) return -1;
        sent += n;
    }
    return 0;
}

int recv_all(SOCKET s, void *buf, size_t len) {
    size_t recvd = 0;
    char *p = (char*)buf;
    while (recvd < len) {
        int n = recv(s, p + recvd, (int)(len - recvd), 0);
        if (n == 0 || n == SOCKET_ERROR) return -1;
        recvd += n;
    }
    return 0;
}

uint64_t htonll(uint64_t v) {
    uint32_t hi = htonl((uint32_t)(v >> 32));
    uint32_t lo = htonl((uint32_t)(v & 0xFFFFFFFFULL));
    return (((uint64_t)lo) << 32) | hi;
}
uint64_t ntohll(uint64_t v) { return htonll(v); }

int handle_client(SOCKET client) {
    uint32_t name_len_n;
    if (recv_all(client, &name_len_n, sizeof(name_len_n)) < 0) return -1;
    uint32_t name_len = ntohl(name_len_n);
    if (name_len == 0 || name_len > 64*1024) return -1;

    char *filename = (char*)malloc(name_len + 1);
    if (!filename) return -1;
    if (recv_all(client, filename, name_len) < 0) { free(filename); return -1; }
    filename[name_len] = '\0';

    FILE *f = fopen(filename, "rb");
    if (!f) {
        uint8_t status = 0;
        send_all(client, &status, 1);
        char errmsg[512];
        snprintf(errmsg, sizeof(errmsg), "File '%s' not found or cannot be opened.", filename);
        uint32_t elen_n = htonl((uint32_t)strlen(errmsg));
        send_all(client, &elen_n, sizeof(elen_n));
        send_all(client, errmsg, strlen(errmsg));
        free(filename);
        return 0;
    }

  
    if (fseek(f, 0, SEEK_END) != 0) { fclose(f); free(filename); return -1; }
    long long fsize_ll = _ftelli64(f);
    fseek(f, 0, SEEK_SET);
    if (fsize_ll < 0) { fclose(f); free(filename); return -1; }
    uint64_t fsize = (uint64_t)fsize_ll;

    
    uint8_t status = 1;
    if (send_all(client, &status, 1) < 0) { fclose(f); free(filename); return -1; }

    
    uint64_t fsize_n = htonll(fsize);
    if (send_all(client, &fsize_n, sizeof(fsize_n)) < 0) { fclose(f); free(filename); return -1; }

    char buf[CHUNK];
    size_t r;
    while ((r = fread(buf, 1, sizeof(buf), f)) > 0) {
        if (send_all(client, buf, r) < 0) { fclose(f); free(filename); return -1; }
    }

    fclose(f);
    free(filename);
    return 0;
}

int main(int argc, char *argv[]) {
    printf("Chethana.C (1BM23CS077)\n");

    if (argc != 2) {
        fprintf(stderr, "Usage: %s <port>\n", argv[0]);
        return 1;
    }
    int port = atoi(argv[1]);

    WSADATA wsa;
    if (WSAStartup(MAKEWORD(2,2), &wsa) != 0) {
        fprintf(stderr, "WSAStartup failed\n");
        return 1;
    }

    SOCKET srv = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (srv == INVALID_SOCKET) { fprintf(stderr, "socket failed\n"); WSACleanup(); return 1; }

    
    char yes = 1;
    setsockopt(srv, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));

    struct sockaddr_in sa;
    sa.sin_family = AF_INET;
    sa.sin_port = htons((unsigned short)port);
    sa.sin_addr.s_addr = INADDR_ANY;

    if (bind(srv, (struct sockaddr*)&sa, sizeof(sa)) == SOCKET_ERROR) {
        fprintf(stderr, "bind failed\n");
        closesocket(srv); WSACleanup(); return 1;
    }
    if (listen(srv, BACKLOG) == SOCKET_ERROR) {
        fprintf(stderr, "listen failed\n");
        closesocket(srv); WSACleanup(); return 1;
    }

    printf("Server listening on port %d. Put files in this folder to serve.\n", port);

    for (;;) {
        struct sockaddr_in cli;
        int clin = sizeof(cli);
        SOCKET client = accept(srv, (struct sockaddr*)&cli, &clin);
        if (client == INVALID_SOCKET) {
            fprintf(stderr, "accept failed\n");
            continue;
        }
        char ipbuf[INET_ADDRSTRLEN];
        inet_ntop(AF_INET, &cli.sin_addr, ipbuf, sizeof(ipbuf));
        printf("Client connected: %s:%d\n", ipbuf, ntohs(cli.sin_port));

        handle_client(client);

        closesocket(client);
        printf("Client connection closed.\n");
    }

    closesocket(srv);
    WSACleanup();
    return 0;
}
